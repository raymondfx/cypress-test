"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrayClientServer = void 0;
const form_data_1 = __importDefault(require("form-data"));
const fs_1 = __importDefault(require("fs"));
const importExecutionResultsConverterServer_1 = require("../../conversion/importExecutionResults/importExecutionResultsConverterServer");
const requests_1 = require("../../https/requests");
const logging_1 = require("../../logging/logging");
const xrayClient_1 = require("./xrayClient");
class XrayClientServer extends xrayClient_1.XrayClient {
    apiBaseURL;
    /**
     * Construct a new Xray Server client.
     *
     * @param apiBaseURL the Xray server base endpoint
     * @param credentials the credentials to use during authentication
     */
    constructor(apiBaseURL, credentials) {
        super(credentials);
        this.apiBaseURL = apiBaseURL;
    }
    async dispatchImportTestExecutionResultsRequest(results) {
        const json = new importExecutionResultsConverterServer_1.ImportExecutionResultsConverterServer().convertExecutionResults(results);
        if (!json.tests || json.tests.length === 0) {
            return null;
        }
        return this.credentials
            .getAuthenticationHeader()
            .catch((error) => {
            (0, logging_1.logError)(`Failed to authenticate: "${error}"`);
            this.writeErrorFile(error, "authenticationError");
            throw error;
        })
            .then(async (header) => {
            (0, logging_1.logInfo)(`Uploading test results to ${this.apiBaseURL}...`);
            const progressInterval = this.startResponseInterval(this.apiBaseURL);
            try {
                const response = await requests_1.Requests.post(`${this.apiBaseURL}/rest/raven/latest/api/import/execution`, json, {
                    headers: {
                        ...header,
                    },
                });
                (0, logging_1.logSuccess)(`Successfully uploaded test execution results to ${response.data.testExecIssue.key}.`);
                return response.data.testExecIssue.key;
            }
            finally {
                clearInterval(progressInterval);
            }
        });
    }
    dispatchExportCucumberTestsRequest(keys, filter) {
        throw new Error("Method not implemented.");
    }
    async dispatchImportCucumberTestsRequest(file, projectKey) {
        const header = await this.credentials.getAuthenticationHeader();
        (0, logging_1.logInfo)("Importing cucumber feature files...");
        const progressInterval = setInterval(() => {
            (0, logging_1.logInfo)("Still importing...");
        }, 5000);
        try {
            const fileContent = fs_1.default.createReadStream(file);
            const form = new form_data_1.default();
            form.append("file", fileContent);
            const response = await requests_1.Requests.post(`${this.apiBaseURL}/rest/raven/latest/import/feature?projectKey=${projectKey}`, form, {
                headers: {
                    ...header,
                    ...form.getHeaders(),
                },
            });
            // Happens when scenarios cause errors in Xray.
            // E.g. typos in Gherkin keywords ('Scenariot').
            if ("message" in response.data) {
                if (response.data.testIssues.length > 0) {
                    (0, logging_1.logSuccess)("Successfully updated or created test issues:", JSON.stringify(response.data.testIssues));
                }
                if (response.data.preConditionIssues.length > 0) {
                    (0, logging_1.logSuccess)("Successfully updated or created precondition issues:", JSON.stringify(response.data.preConditionIssues));
                }
            }
            else {
                (0, logging_1.logSuccess)("Successfully updated or created issues:", JSON.stringify(response.data));
            }
            return response.data;
        }
        finally {
            clearInterval(progressInterval);
        }
    }
}
exports.XrayClientServer = XrayClientServer;
