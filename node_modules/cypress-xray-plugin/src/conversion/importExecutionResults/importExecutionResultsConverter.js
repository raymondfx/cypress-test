"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportExecutionResultsConverter = void 0;
const context_1 = require("../../context");
const logging_1 = require("../../logging/logging");
const testStatus_1 = require("../../types/testStatus");
const util_1 = require("../../types/util");
/**
 * @template XrayTestType - the Xray test type
 * @template XrayTestInfoType - the Xray test information type
 */
class ImportExecutionResultsConverter {
    /**
     * Convert Cypress run results into Xray JSON format, ready to be sent to Xray's import
     * execution results endpoint.
     *
     * @param results the run results
     * @returns the Xray JSON data
     */
    convertExecutionResults(results) {
        const json = {
            testExecutionKey: context_1.CONTEXT.config.jira.testExecutionIssueKey,
        };
        json.info = this.getTestExecutionInfo(results);
        const testsByTitle = this.mapTestsToTitles(results);
        const attemptsByTitle = this.mapAttemptsToTitles(testsByTitle);
        testsByTitle.forEach((testResults, title) => {
            let test;
            // TODO: Support multiple iterations.
            const testResult = testResults[testResults.length - 1];
            try {
                const attempts = attemptsByTitle.get(title);
                // TODO: Support multiple iterations.
                test = this.getTest(attempts[attempts.length - 1]);
                const issueKey = this.getTestIssueKey(testResult);
                if (issueKey !== null) {
                    test.testKey = issueKey;
                    if (context_1.CONTEXT.config.plugin.overwriteIssueSummary) {
                        test.testInfo = this.getTestInfo(testResult);
                    }
                }
                else {
                    if (!context_1.CONTEXT.config.jira.createTestIssues) {
                        throw new Error("No test issue key found in test title and the plugin is not allowed to create new test issues");
                    }
                    test.testInfo = this.getTestInfo(testResult);
                }
                if (!json.tests) {
                    json.tests = [test];
                }
                else {
                    json.tests.push(test);
                }
            }
            catch (error) {
                let reason = error;
                if (error instanceof Error) {
                    reason = error.message;
                }
                (0, logging_1.logWarning)(`${reason}. Skipping result upload for test "${title}".`);
            }
        });
        return json;
    }
    /**
     * Remove milliseconds from ISO time string. Some Jira Xray instances cannot handle milliseconds in the string.
     *
     * @param time a date time string in ISO format
     * @returns the truncated date time string
     * @example
     *   const time = truncateISOTime("2022-12-01T02:30:44.744Z")
     *   console.log(time); // "2022-12-01T02:30:44Z"
     */
    truncateISOTime(time) {
        return time.split(".")[0] + "Z";
    }
    /**
     * Retrieve the overall start date of multiple Cypress test results.
     *
     * @param attempts the Cypress test results
     * @returns the tests' start date
     */
    getAttemptsStartDate(attempts) {
        let start = null;
        attempts.forEach((attempt) => {
            const attemptDate = this.getAttemptStartDate(attempt);
            if (!start || attemptDate < start) {
                start = attemptDate;
            }
        });
        return start;
    }
    /**
     * Retrieve the start date of a single Cypress test result.
     *
     * @param attempt the Cypress test result
     * @returns the test's start date
     */
    getAttemptStartDate(attempt) {
        return new Date(attempt.startedAt);
    }
    /**
     * Retrieve the end date of multiple Cypress test results.
     *
     * @param attempts the Cypress test results
     * @returns the tests' end date
     */
    getAttemptsEndDate(attempts) {
        let end = null;
        attempts.forEach((attempt) => {
            const attemptEndDate = this.getAttemptEndDate(attempt);
            if (!end || attemptEndDate > end) {
                end = attemptEndDate;
            }
        });
        return end;
    }
    /**
     * Retrieve the end date of a single Cypress test result.
     *
     * @param attempt the Cypress test result
     * @returns the test's end date
     */
    getAttemptEndDate(attempt) {
        const date = this.getAttemptStartDate(attempt);
        date.setMilliseconds(date.getMilliseconds() + attempt.duration);
        return date;
    }
    /**
     * Returns a {@link Status} enum value for a single Cypress test result.
     *
     * @param attempt the Cypress test result
     * @returns a corresponding status
     */
    getStatus(attempt) {
        const status = testStatus_1.Status[(0, util_1.getEnumKeyByEnumValue)(testStatus_1.Status, attempt.state)];
        if (!status) {
            throw new Error(`Unknown Cypress test status: '${attempt.state}'`);
        }
        return status;
    }
    /**
     * Returns a step action description truncated to the maximum length Xray
     * allows.
     *
     * @param action the step's action description
     * @returns the truncated or unmodified description if it's short enough
     */
    truncateStepAction(action) {
        if (action.length <= context_1.CONTEXT.config.xray.steps.maxLengthAction) {
            return action;
        }
        // Subtract 3 for the dots.
        const truncated = action.substring(0, context_1.CONTEXT.config.xray.steps.maxLengthAction - 3);
        return `${truncated}...`;
    }
    mapTestsToTitles(results) {
        const map = new Map();
        results.runs.forEach((run) => {
            run.tests.forEach((test) => {
                const title = test.title.join(" ");
                if (map.has(title)) {
                    map.get(title).push(test);
                }
                else {
                    map.set(title, [test]);
                }
            });
        });
        return map;
    }
    mapAttemptsToTitles(testsByTitle) {
        const map = new Map();
        testsByTitle.forEach((testResults, title) => {
            const attempts = testResults.flatMap((testResult) => testResult.attempts);
            if (map.has(title)) {
                map.set(title, map.get(title).concat(attempts));
            }
            else {
                map.set(title, attempts);
            }
        });
        return map;
    }
    getTestExecutionInfo(results) {
        return {
            project: context_1.CONTEXT.config.jira.projectKey,
            startDate: this.truncateISOTime(results.startedTestsAt),
            finishDate: this.truncateISOTime(results.endedTestsAt),
            description: this.getDescription(results),
            summary: this.getTextExecutionResultSummary(results),
            testPlanKey: context_1.CONTEXT.config.jira.testPlanIssueKey,
        };
    }
    getTextExecutionResultSummary(results) {
        return (context_1.CONTEXT.config.jira.testExecutionIssueSummary ||
            `Execution Results [${new Date(results.startedTestsAt).getTime()}]`);
    }
    getDescription(results) {
        return (context_1.CONTEXT.config.jira.testExecutionIssueDescription ||
            "Cypress version: " +
                results.cypressVersion +
                " Browser: " +
                results.browserName +
                " (" +
                results.browserVersion +
                ")");
    }
    getTestIssueKey(testResult) {
        const regex = new RegExp(`(${context_1.CONTEXT.config.jira.projectKey}-\\d+)`, "g");
        // The last element usually refers to an individual test.
        // The ones before might be test suite titles.
        const testCaseTitle = testResult.title[testResult.title.length - 1];
        const matches = testCaseTitle.match(regex);
        if (!matches) {
            // Test case title does not contain the issue's key.
            // Maybe it was provided via Cucumber as a scenario tag?
            if (context_1.CONTEXT.config.cucumber.issues && testCaseTitle in context_1.CONTEXT.config.cucumber.issues) {
                return context_1.CONTEXT.config.cucumber.issues[testCaseTitle];
            }
        }
        else if (matches.length === 1) {
            return matches[0];
        }
        else {
            throw new Error(`Multiple test keys found in test "${testCaseTitle}": ${matches.join(", ")}`);
        }
        return null;
    }
}
exports.ImportExecutionResultsConverter = ImportExecutionResultsConverter;
